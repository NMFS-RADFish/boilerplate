import fs from "fs";
import path from "path";
import * as sass from "sass";
import { getCacheDir, computeFileHash } from "./utils.js";
import { formatUswdsValue } from "./scss.js";

/**
 * Check if USWDS needs recompilation based on cache
 */
export function needsRecompilation(cacheDir, tokensPath) {
  const cachePath = path.join(cacheDir, ".uswds-cache.json");
  const cssPath = path.join(cacheDir, "uswds-precompiled.css");

  // Need recompilation if cache or CSS doesn't exist
  if (!fs.existsSync(cachePath) || !fs.existsSync(cssPath)) {
    return true;
  }

  try {
    const cache = JSON.parse(fs.readFileSync(cachePath, "utf-8"));
    return cache.tokensHash !== computeFileHash(tokensPath);
  } catch {
    return true;
  }
}

/**
 * Generate SCSS entry file content for USWDS compilation
 */
export function generateUswdsEntryScss(uswdsTokens) {
  // Build USWDS @use statement with all token variables
  const uswdsTokensStr = Object.entries(uswdsTokens)
    .map(([key, value]) => {
      // Convert camelCase to kebab-case for USWDS format
      const kebabKey = key.replace(/([A-Z])/g, "-$1").toLowerCase();
      // Convert kebab-case to USWDS format: base-lightest â†’ theme-color-base-lightest
      const uswdsKey = `theme-color-${kebabKey}`;
      // Format value: hex colors unquoted, token names quoted
      const formattedValue = formatUswdsValue(value);
      return `  $${uswdsKey}: ${formattedValue}`;
    })
    .join(",\n");

  return `/**
 * AUTO-GENERATED USWDS Entry Point
 * Generated by RADFish theme plugin for sass.compile()
 *
 * DO NOT EDIT MANUALLY - changes will be overwritten
 */

@use "uswds-core" with (
${uswdsTokensStr},
  $theme-show-notifications: false
);

@forward "uswds";
`;
}

/**
 * Pre-compile USWDS with theme tokens to a static CSS file
 */
export function precompileUswds(themeDir, themeName, uswdsTokens) {
  const cacheDir = getCacheDir(themeName);
  const entryPath = path.join(cacheDir, "_uswds-entry.scss");
  const outputPath = path.join(cacheDir, "uswds-precompiled.css");
  const tokensPath = path.join(themeDir, "styles", "theme.scss");

  // Ensure cache directory exists
  if (!fs.existsSync(cacheDir)) {
    fs.mkdirSync(cacheDir, { recursive: true });
  }

  console.log("[radfish-theme] Pre-compiling USWDS...");
  const startTime = Date.now();

  // Generate entry SCSS with tokens
  const entryContent = generateUswdsEntryScss(uswdsTokens);
  fs.writeFileSync(entryPath, entryContent);

  // Compile with sass
  const result = sass.compile(entryPath, {
    loadPaths: [path.join(process.cwd(), "node_modules/@uswds/uswds/packages")],
    style: "compressed",
    quietDeps: true,
  });

  fs.writeFileSync(outputPath, result.css);

  // Save cache manifest
  const cacheData = {
    tokensHash: computeFileHash(tokensPath),
    compiledAt: new Date().toISOString(),
  };
  fs.writeFileSync(
    path.join(cacheDir, ".uswds-cache.json"),
    JSON.stringify(cacheData, null, 2)
  );

  const elapsed = Date.now() - startTime;
  console.log(`[radfish-theme] USWDS pre-compiled in ${elapsed}ms: ${outputPath}`);
}

/**
 * Pre-compile theme SCSS file (theme.scss) to CSS
 */
export function precompileThemeScss(themeDir, themeName) {
  const cacheDir = getCacheDir(themeName);
  const stylesDir = path.join(themeDir, "styles");

  // Ensure cache directory exists
  if (!fs.existsSync(cacheDir)) {
    fs.mkdirSync(cacheDir, { recursive: true });
  }

  const inputPath = path.join(stylesDir, "theme.scss");
  const outputPath = path.join(cacheDir, "theme.css");

  if (fs.existsSync(inputPath)) {
    try {
      const result = sass.compile(inputPath, {
        loadPaths: [
          stylesDir,
          cacheDir,
          path.join(process.cwd(), "node_modules/@uswds/uswds/packages"),
        ],
        style: "compressed",
        quietDeps: true,
      });
      fs.writeFileSync(outputPath, result.css);
      console.log(`[radfish-theme] Compiled theme.scss -> theme.css`);
    } catch (err) {
      console.error(`[radfish-theme] Error compiling theme.scss:`, err.message);
    }
  }
}
